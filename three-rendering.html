<html>
<head>
<script src="util.js"></script>
<script src="multi-genetic.js"></script>
<script>
</script>
<style>
  canvas {
    margin: 0; 
    padding: 0; 
  }

  body {
    margin: 0; 
    padding: 0; 
  }

  #canvas3d {
    height: 100%;
  }
</style>
</head>
<body>
  <div id="canvas3d"></div>
  <script src="three.js"></script>
  <!-- <script src="Ocean.js"></script> -->
  <script src="OrbitControls.js"></script>
  <script type="module">

    import { Ocean } from './Ocean.js';

    let lastTime = (new Date()).getTime()
    let renderer, element
    let container, scene, divContainer, camera, controls, hemiLight
    let population, ocean
    let organisms = [] 

    function init() {
      divContainer = document.getElementById('canvas3d')

      renderer = new THREE.WebGLRenderer({ autoClear: true })
      // renderer.setClearColor(0xffffff, 1)
      renderer.physicallyCorrectLights = true
      renderer.gammaInput = true
			renderer.gammaOutput = true
			renderer.shadowMap.enabled = true
			renderer.toneMapping = THREE.ReinhardToneMapping
      renderer.setSize( window.innerWidth, window.innerHeight )
      element = renderer.domElement
      divContainer.appendChild(element)

      scene = new THREE.Scene()

      camera = new THREE.PerspectiveCamera(55.0, window.innerWidth / window.innerHeight, 0.5, 300000)
      camera.position.x = -450 
      camera.position.y = -650 
      camera.position.z = 450
      camera.lookAt(0,0,0)

      let floorMaterial = new THREE.MeshStandardMaterial({ color: 255 })
      let cubeMaterial = new THREE.MeshStandardMaterial({ roughness: 0.7,
				color: 0xffffff,
				bumpScale: 0.002,
        metalness: 0.2
      })
      let sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 })
      let cylinderMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 })

      let floorGeometry = new THREE.PlaneBufferGeometry(2000, 2000)
      let floor = new THREE.Mesh(floorGeometry, floorMaterial)
      floor.rotation.x = - Math.PI / 2.0;

      container = new THREE.Object3D()
      container.add(floor)

      // scene.add(floor)

      hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );
			scene.add( hemiLight );
      
      let boxGeometry = new THREE.BoxBufferGeometry( 50, 50, 50 )
      let boxMesh = new THREE.Mesh( boxGeometry, cubeMaterial )
      boxMesh.position.set(0, 27.5, 0 )
      boxMesh.castShadow = true
      scene.add( boxMesh )

      let cylinderGeometry = new THREE.CylinderGeometry(20, 20, 25, 32, 1)
      let cylinderMesh = new THREE.Mesh( cylinderGeometry, cylinderMaterial )
      cylinderMesh.castShadow = true 
      scene.add(cylinderMesh)

      var light = new THREE.DirectionalLight(0xffffff, 10, 100);
      light.position.set(1200, 200, 0);
      light.castShadow = true; // default false

      console.log({ position: light.position })
      // light.shadow.mapSize.width = 1024;
      // light.shadow.mapSize.height = 1024;
      // light.shadow.camera.left = -2000;
      // light.shadow.camera.right = 2000;
      // light.shadow.camera.top = 2000;
      // light.shadow.camera.bottom = -2000;
      // light.shadow.camera.near = 0.5;
      // light.shadow.camera.far = 2000;

      scene.add(light);

      let sphereGeometry = new THREE.SphereBufferGeometry(0.5, 16, 16)
      
      evolute(population, function(offspring) {
        population = offspring

        for(var i = 0; i < population.length; i++) {
          let bulbLight = new THREE.PointLight( 0xffee88, 100, 1000, 2 );
          let bulbMat = new THREE.MeshStandardMaterial( {
					  emissive: 0xffffee,
					  emissiveIntensity: 30,
					  color: 0x000000
          })
          bulbLight.add(new THREE.Mesh( sphereGeometry, bulbMat ))
          
          let x = (population[i]['x'].fitness / 2) + 12.5
          let y = population[i]['y'].fitness / 2
          let z = population[i]['z'].fitness / 2

          bulbLight.position.set(x, y, z)
          bulbLight.castShadow = true 
          bulbLight.power = 18000 


          scene.add(bulbLight)

          organisms.push(bulbLight)
        }
      })

      let controls = new THREE.OrbitControls( camera, renderer.domElement)
      // controls.minDistance = 0
      // controls.maxDistance = 200 
      // controls.minPolarAngle = 0
      // controls.maxPolarAngle = Math.PI * 0.495
      // controls.userPan = false 

      window.addEventListener( 'resize', onWindowResize, false );

      let gsize = 512
      let res = 1024
      let gres = res / 2
      let origx = - gsize / 2
      let origz = - gsize / 2

      ocean = new Ocean(renderer, {
        USE_HALF_FLOAT: false,
        INITIAL_SIZE: 512.0,
        INITIAL_WIND: [ 10.0, 10.0 ],
        INITIAL_CHOPPINESS: 1.5,
        // CLEAR_COLOR: [ 1.0, 1.0, 1.0, 0.0 ],
        CLEAR_COLOR: [ 100.0, 100.0, 100.0, 0.0 ],
        // GEOMETRY_ORIGIN: [ origx, origz ],
        GEOMETRY_ORIGIN: [ 1000, 1000 ],
        // SUN_DIRECTION: [ - 1.0, 1.0, 1.0 ],
        SUN_DIRECTION: light.position.clone().normalize(),
        OCEAN_COLOR: new THREE.Vector3( 0.004, 0.016, 0.047 ),
        // SKY_COLOR: new THREE.Vector3( 3.2, 9.6, 12.8 ),
        SKY_COLOR: new THREE.Vector3( 3.2, 9.6, 12.8 ),
        // EXPOSURE: 0.35,
        EXPOSURE: 0.08,
        GEOMETRY_RESOLUTION: gres,
        GEOMETRY_SIZE: gsize,
        RESOLUTION: res
      })

      ocean.materialOcean.uniforms[ "u_projectionMatrix" ] = { value: camera.projectionMatrix }
			ocean.materialOcean.uniforms[ "u_viewMatrix" ] = { value: camera.matrixWorldInverse }
			ocean.materialOcean.uniforms[ "u_cameraPosition" ] = { value: camera.position }
      console.log({ ocean: ocean })

      scene.add(ocean.oceanMesh)

      render()
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()

      renderer.setSize( window.innerWidth, window.innerHeight )
    }

    function resize() {
      let width = divContainer.offsetWidth
      let height = divContainer.offsetHeight
      camera.aspect = width / height
      camera.updateProjectionMatrix()

      renderer.setSize(width, height)
      render()
    }

    function render() {
      requestAnimationFrame(render);

      evolute(population, function(offspring) {
        population = offspring

        for(var i = 0; i < population.length; i++) {
          let organism = organisms[i]

          organism.position.x = (population[i]['x'].fitness / 2) + 12.5
          organism.position.y = population[i]['y'].fitness / 2
          organism.position.z = population[i]['z'].fitness / 2
        }
      })

      var currentTime = new Date().getTime();
      ocean.deltaTime = ( currentTime - lastTime ) / 1000 || 0.0;
      lastTime = currentTime;
      ocean.render( ocean.deltaTime );
      ocean.overrideMaterial = ocean.materialOcean;
      if ( ocean.changed ) {
        ocean.materialOcean.uniforms[ "u_size" ].value = ocean.size;
        ocean.materialOcean.uniforms[ "u_sunDirection" ].value.set( ocean.sunDirectionX, ocean.sunDirectionY, ocean.sunDirectionZ );
        ocean.materialOcean.uniforms[ "u_exposure" ].value = ocean.exposure;
        ocean.changed = false;
      }
      ocean.materialOcean.uniforms[ "u_normalMap" ].value = ocean.normalMapFramebuffer.texture;
      ocean.materialOcean.uniforms[ "u_displacementMap" ].value = ocean.displacementMapFramebuffer.texture;
      ocean.materialOcean.uniforms[ "u_projectionMatrix" ].value = camera.projectionMatrix;
      ocean.materialOcean.uniforms[ "u_viewMatrix" ].value = camera.matrixWorldInverse;
      ocean.materialOcean.uniforms[ "u_cameraPosition" ].value = camera.position;
      ocean.materialOcean.depthTest = true;

      renderer.toneMappingExposure = Math.pow( 0.68, 5.0 )
      renderer.toneMappingExposure = Math.pow( 1, 5.0 )
      renderer.shadowMap.enabled = true
      renderer.setPixelRatio( window.devicePixelRatio );

      hemiLight.intensity = 0.0001

      renderer.render(scene, camera);
    }

    init()
  </script>
</body>
</html>