<html>
<head>
<style>
  body {
    background-color: #000;
    margin: 0px;
    overflow: hidden;
  }
</style>
<script src="http://threejs.org/build/three.min.js"></script>
<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script id="vs_depth" type="x-shader/x-vertex">
// verbatim from http://blog.edankwan.com/post/three-js-advanced-tips-shadow

uniform float time;

void main() {

    vec3 offset = vec3(
        sin(position.x * 10.0 + time) * 15.0,
        sin(position.y * 10.0 + time + 31.512) * 15.0,
        sin(position.z * 10.0 + time + 112.512) * 15.0
    );

    vec3 pos = position + offset;

    vec4 worldPosition = modelMatrix * vec4(pos, 1.0);

    gl_Position = projectionMatrix * viewMatrix * worldPosition;

}
</script>
<script id="fs" type="x-shader/x-fragment">
// originally from http://blog.edankwan.com/post/three-js-advanced-tips-shadow
// removed anything but depth-shadow

varying vec3 vNormal;
varying vec3 vWorldPosition;

uniform vec3 lightPosition;

void main(void) {

    vec3 lightDirection = normalize(lightPosition - vWorldPosition);

    float c = 0.35 + max(0.0, dot(vNormal, lightDirection)) * 0.4;

    gl_FragColor = vec4(c, c, c, 1.0);

}
</script>
<script id="vs" type="x-shader/x-vertex">
// originally from http://blog.edankwan.com/post/three-js-advanced-tips-shadow
// removed anything but depth-shadow

varying vec3 vNormal;
varying vec3 vWorldPosition;

uniform float time;

void main() {

    // adding some displacement based on the vertex position
    vec3 offset = vec3(
        sin(position.x * 10.0 + time) * 25.0,
        sin(position.y * 10.0 + time + 31.512) * 25.0,
        sin(position.z * 10.0 + time + 112.512) * 25.0
    );

    vec3 pos = position + offset;

    // just add some noise to the normal
    vNormal = normalMatrix * vec3(normal + normalize(offset) * 0.2);

    vec4 worldPosition = modelMatrix * vec4(pos, 1.0);

    // store the world position as varying for lighting
    vWorldPosition = worldPosition.xyz;

    gl_Position = projectionMatrix * viewMatrix * worldPosition;

}
</script>
</head>
<body>
  <script>
    var mesh, renderer, scene, camera, controls;
var ground, time = 0;


init();
animate();

function init() {

  vs_depth = document.getElementById('vs_depth').textContent;
  vs = document.getElementById('vs').textContent;
  fs = document.getElementById('fs').textContent;

  // renderer
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // scene
  scene = new THREE.Scene();

  // camera
  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.5, 300000);
  camera.position.set(620, 620, 1020);

  // controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);

  // ambient
  // scene.add(new THREE.AmbientLight(0x222222));

  // light
  var light = new THREE.DirectionalLight(0xffffff, 1, 100);
  light.position.set(700, 700, 500);
  // light.castShadow = true; // default false
  // light.shadow.mapSize.width = 1024;
  // light.shadow.mapSize.height = 1024;
  // light.shadow.camera.left = -2000;
  // light.shadow.camera.right = 2000;
  // light.shadow.camera.top = 2000;
  // light.shadow.camera.bottom = -2000;
  // light.shadow.camera.near = 0.5;
  // light.shadow.camera.far = 2000;

  scene.add(light);

  var helper = new THREE.CameraHelper(light.shadow.camera);
  scene.add(helper);

  // axes
  // scene.add( new THREE.AxisHelper( 20 ) );

  // ground plane
  var ground_geo = new THREE.PlaneGeometry(3000, 3000, 10, 10);
  var ground_mat = new THREE.MeshPhongMaterial({
    color: new THREE.Color(0xAAAAAA),
    shininess: 5
  });

  ground = new THREE.Mesh(ground_geo, ground_mat);
  ground.position.y = -250;
  ground.rotation.x = -1.57;
  ground.castShadow = false;
  ground.receiveShadow = true;
  scene.add(ground);


  // geometry
  var geometry = new THREE.IcosahedronGeometry(200, 3);

  // material
  var material = new THREE.ShaderMaterial({
    vertexShader: vs,
    fragmentShader: fs,
    uniforms: THREE.UniformsUtils.merge([{
      lightPosition: {
        value: light.position
      },
      time: {
        value: 0
      }
    }])
  });

  // mesh
  mesh = new THREE.Mesh(geometry, material);
  mesh.castShadow = true;
  mesh.receiveShadow = true;

  mesh.customDepthMaterial = new THREE.ShaderMaterial({
    vertexShader: vs_depth,
    fragmentShader: THREE.ShaderLib.basic.fragmentShader,
    uniforms: material.uniforms
  });

  scene.add(mesh);

}

function animate() {

  requestAnimationFrame(animate);

  //controls.update();
  time += 0.1;
  mesh.position.y = Math.sin(time * 0.5) * 50;
  mesh.material.uniforms.time.value = time;

  renderer.render(scene, camera);

}

  </script>
</body>
</html>